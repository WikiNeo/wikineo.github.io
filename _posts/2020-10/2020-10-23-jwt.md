---
title: "Implement JSON Web Token (JWT) Authentication using AccessToken and RefreshToken"
published: true
tags: Network
---

## The Need for Authentication

The first and the most basic requirement of the web APIs is to prevent
unauthorized access to the services.

The simplest way to solve this is to add a registration process, in which a user
will register using a unique identifier like email and choose a password. For
all the subsequent requests the user will send the unique identifier and his
password (most preferably in HTTP header).

This is called the Basic Authentication scheme and is defined in RFC7617. In
this scheme, we send the unique identifier and password pair encoded using
base64. For example, we combine the credentials in colon-separated string i.e.
`username:password` and then encode in base64. We should send this string in the
HTTP header, `Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=`. Since we are
sending a text over the network, which can be decoded, we should always use
Basic scheme along with HTTPS/TLS.

But in the Basic scheme, we will have to send the credentials over the wire with
each request but we would not want to store the credentials locally. So, we can
implement: Signup/Login => Call Other APIs.

## Token Solution

When a user registers then the backend server generates a token and sends it to
the client. That token is sent back to the backend for each subsequent API call
by the client through the HTTP Authorization header. This token has a small-time
validity and can not use use after its expiration time. To receive a new token
the user logs in again with his credentials [we should always use the HTTPS/TLS
connection to send the user credentials]

## Token Content

Through a consensus, a standard for the structure of the token is adopted and
documented in the RFC7519. This token is called JSON Web Token (JWT)

```shell
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZnRlcmFjYWRlbXkuY29tIiwiYXVkIjoiYWZ0ZXJhY2FkZW15X3VzZXJzIiwic3ViIjoiNWU3Yjk1OTIzMDg1ODcyZDNjMzc4ZjM1IiwiaWF0IjoxNTg1MTU4ODc4LCJleHAiOjE1ODc3NTA4NzgsInBybSI6IjNlZDcyM2NiYjI3YmVmNjVkNmUwMzI1NTBlNDNmOTBhZjczNmFjNDJjOTUxYzBmNjljMzE2ZTU4NTRlZjc4NDczYjNkMzc0ZjI4ZWNiZTFkN2FmYTNlYjQ5YjVjYjM2MjY5ZWI0N2YyMjAxOTc0ODRiZGQyNDc4NzE4NzkxODFhIn0.OotEsfdYe3DYTM6fMvsiMmG9TBgJyL4MOpi-cDi2wB1Qzgq__klHLZzB1cEYat0l8vPXm4Zok_yX4VvRn4cWDw
```

This is a JWT. The main objective of having this structure is listed below:

- We can add data in the token to identify the context.
- We can sign the token to ensure its authenticity.
- We can add the metadata for token processing instructions.

This JWT is a base64 encoded JSON string having 3 parts separated by a (.) dot.

```shell script
// Part 1
atob('eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9')
Output: "{"alg":"RS256","typ":"JWT"}"

// Part 2
atob('eyJpc3MiOiJhZnRlcmFjYWRlbXkuY29tIiwiYXVkIjoiYWZ0ZXJhY2FkZW15X3VzZXJzIiwic3ViIjoiNWU3Yjk1OTIzMDg1ODcyZDNjMzc4ZjM1IiwiaWF0IjoxNTg1MTU4ODc4LCJleHAiOjE1ODc3NTA4NzgsInBybSI6IjNlZDcyM2NiYjI3YmVmNjVkNmUwMzI1NTBlNDNmOTBhZjczNmFjNDJjOTUxYzBmNjljMzE2ZTU4NTRlZjc4NDczYjNkMzc0ZjI4ZWNiZTFkN2FmYTNlYjQ5YjVjYjM2MjY5ZWI0N2YyMjAxOTc0ODRiZGQyNDc4NzE4NzkxODFhIn0')
Output: "{"iss":"afteracademy.com","aud":"afteracademy_users","sub":"5e7b95923085872d3c378f35","iat":1585158878,"exp":1587750878,"prm":"3ed723cbb27bef65d6e032550e43f90af736ac42c951c0f69c316e5854ef78473b3d374f28ecbe1d7afa3eb49b5cb36269eb47f220197484bdd247871879181a"}"

// Part 3
atob('OotEsfdYe3DYTM6fMvsiMmG9TBgJyL4MOpi-cDi2wB1Qzgq__klHLZzB1cEYat0l8vPXm4Zok_yX4VvRn4cWDw')
Output: ???
```

```javascript
// Part 1
{
  "alg": "RS256",
  "typ": "JWT"
}

// Part 2
{
  "iss": "afteracademy.com",
  "aud": "afteracademy_users",
  "sub": "5e7b95923085872d3c378f35",
  "iat": 1585158878,
  "exp": 1587750878,
  "prm": "3ed723cbb27bef65d6e032550e43f90af736ac42c951c0f69c316e5854ef78473b3d374f28ecbe1d7afa3eb49b5cb36269eb47f220197484bdd247871879181a"
}

// Part 3
???
```

## The Three Parts of the JWT

1. Header: It contains the metadata for the signing method and the encryption
   method applied to the token
2. Payload: It contains information about the authenticated user. The RFC
   defines and recommends some standard keys for this JSON object but it is not
   mandatory and we can add any data in this payload.
3. Signature

The signature is what makes this whole system work. We encrypt the hash of the
contents of the token, i.e. Header and Payload using the encryption algorithms
like RSA256 (RSA Signature with SHA-256), HS256 (HMAC with SHA-256), etc. The
third part of the token contains this encrypted hash string.

In RS256, we have a private key and a public pair. The data hash can be
encrypted using the private key and can only be decrypted using the public key.
This private key needs to be kept secure on the server filesystem. The public
key can be shared with the client if required.

To validate the authenticity of the token, the Header, and the Payload (base64
string parts of the token) are combined and hashed together and the hash is then
validated using the public key to test whether it was actually encrypted using
its private key. This ensures that no one else can either change the original
data in the token or send false data Because the hash value will not match the
originally issued token.

Payload data.

1. iss (Issuer): This identifies the issuing authority of the token. In most of
   the cases, it is the name of the authentication server.
2. aud (Audience): This identifies the recipients of the token who will process
   the JWT and use the information stored in the token.
3. sub (Subject): It identifies the end-user of the token. It usually contains
   the database user id.
4. iat (Issued at): It defines the time when the token was issued.
5. exp (Expiration Time): It defines the time after which the token is
   considered expired and is deemed invalid.
6. prm (param): It is a custom field that I have added to identify the token for
   the user so that we can force invalidate that the token when needed.

## AccessToken

Signup/Login → Receive Token → Send that Token in other APIs

```
POST /v1/login/basic HTTP/1.1
Host: localhost:3000

Request Header:
x-api-key: ASSIGNED_API_KEY
Content-Type: application/json

Request Body:
{
   "email": "ali@mindorks.com",
   "password": "changeit"
}

Response Body:
{
  "statusCode": "10000",
  "message": "Login Success",
  "data": {
    "user": {
      "_id": "5e7b95923085872d3c378f35",
      // other user data
    },
    "tokens": {
      "accessToken": "NEW_JWT_FOR_ACCESS",
      "refreshToken": "NEW_JWT_FOR_REFRESH"
    }
  }
}
```

Now you can use the received `data.tokens.accessToken` in other APIs. The
AccessToken and RefreshToken are stored securely on the client-side, so that the
user does not have to re-login each time he/she opens the website or app. 

It is accepted in the backend community that this JWT should be sent in the
Authorization header with Bearer scheme. Although this scheme is defined for
OAuth2 authentication, it is also recommended in JWT case.

```
POST /v1/writer/blog HTTP/1.1
Host: localhost:3000

Request Header:
x-api-key: ASSIGNED_API_KEY
Content-Type: application/json
Authorization: Bearer RECEIVED_JWT_FOR_ACCESS

Request Body:
{
   "title": "SOME_TITLE",
   // other blog data
}

Response Body:
{
  "statusCode": "10000",
  "message": "Blog created successfully",
  "data": {
     // created blog data
  }
}
```

## RefreshToken

## References

- [Implement JSON Web Token (JWT) Authentication using AccessToken and RefreshToken](https://afteracademy.com/blog/implement-json-web-token-jwt-authentication-using-access-token-and-refresh-token)